# 基础

消息队列两种模式：

1. **点对点模式**（一对一，消费者主动拉取数据，消息收到后消息清除）
   点对点模型通常是一个基于拉取或者轮询的消息传送模型，这种模型从队列中请求信息，而不是将消息推送到客户端。这个模型的特点是发送到队列的消息被一个且只有一个接收者接收处理，即使有多个消息监听者也是如此。
2. **发布/订阅模式**（一对多，数据生产后，推送给所有订阅者）
   发布订阅模型则是一个基于推送的消息传送模型。发布订阅模型可以有多种不同的订阅者，临时订阅者只在主动监听主题时才接收消息，而持久订阅者则监听主题的所有消息，即使当前订阅者不可用，处于离线状态。

## Kafka 体系结构

<img src="/Users/xuping/Library/Application Support/typora-user-images/image-20220511111421102.png" alt="image-20220511111421102" style="zoom:40%;margin-left:0" />

**Topic：**

主题可理解为一个队列。Kafka的消息通过 topic 进行分类，topic 就像是数据库中的"表"，可以被分成若干个分区(类似HBase中建表时预分区)，一个分区对应一个提交日志。消息以追加的方式写入分区，然后以FIFO进行顺序读取，每个分区内的顺序是确定的。

**Partition：**

为了实现扩展性，一个非常大的 topic 可以分布到多个 broker（即服务器）上，一个 topic 可以分为多个 partition，每个 partition 是一个有序的队列。partition 中的每条消息都会被分配一个有序的 id（offset）。将消息发给 consumer，kafka 只保证按一个 partition 中的消息的顺序，不保证一个 topic 的整体（多个 partition 间）的顺序。

* leader/follower
  每个分区对应一个leader，根据(复本数-1)决定了follower的数量，leader的选举由zookeeper决定。在producer写消息时只负责向leader中写，leader负责向follower节点发送数据进行复本冗余

* 分区的好处
  实现负载均衡。分区对于消费者来说，可以提高并发度，提高效率。例如某一个 topic有 n 个分区，可以对应建一个有 m （n >= m）个消费者的消费者组。最好 n = m，当 n > m 时，就意味着某一个消费者会消费多个分区的数据。另外，一个消费者还可以消费多个 Topic 数据

* 分区分配策略

  对于消费者来说，一个 consumer group 中有多个 consumer，一个 topic 有多个 partition，所以肯定会涉及到 partition 的分配问题，即确定每个 partition 由哪个 consumer 来消费，这就是分区分配策略（Partition Assignment Strategy）。

  **分区的所有权从一个消费者移到另一个消费者称为重新平衡（rebalance）**

  假设目前某消费组内只有一个消费者C0，订阅了一个topic，这个topic包含6个分区，也就是说这个消费者C0订阅了6个分区，这时候可能会发生下列三种情况：

  1. 如果这时候消费者组内**新增**了一个**消费者**C1，这个时候就需要把之前分配给C0的6个分区拿出来3个分配给C1
  2. 如果这时候这个topic**多了一些分区**，就要按照某种策略，把多出来的分区分配给C0和C1
  3. 如果这时候C1**消费者挂掉了或者退出**了，不在消费者组里了，那所有的分区需要再次分配给C0

**Producer：**

消息生产者，向 broker 推送消息的客户端。一个消息会被发布到一个特定的 topic 上，producer 默认会将消息均衡地分布到主题的所有分区上(Hash分区器)。

**Consumer：**

消息的消费者，从 Broker 消费消息的客户端。Consumer 可以消费同一个 topic 不同分区的消息，并按照消息生成的顺序读取。 Consumer 通过检查消息的 offset 来区分已经读取过的消息。

实际生产中，消费者在消费数据时可能会出现各种会导致宕机的故障问题，这个时候，如果消费者后续恢复了，它就需要从发生故障前的位置开始继续消费，而不是从头开始消费。所以消费者需要实时的记录自己消费到了哪个offset，便于后续发生故障恢复后继续消费。Kafka 0.9版本之前，consumer 默认将 offset 保存在 Zookeeper 中，从0.9版本开始，consumer 默认将 offset 保存在 Kafka 一个内置的topic中，该topic为 **__consumer_offsets**。

**Broker：**

一台 Kafka 服务器就是一个 Broker。一个集群由多个 Broker 组成。一个 Broker 可以容纳多个 Topic。Brocker 接受来自 Producer 的消息，为消息设置 offset，并提交消息到磁盘保存；并对 Consumer 读取分区的请求作出响应，返回已经提交到磁盘上的信息。