# 索引

主要梳理 InnoDB 存储引擎的索引，其他存储引擎用的不多，就先不梳理了。首先就是索引的叫法，包括以下几种：**聚簇索引**、**非聚集索引**、**单列索引**、**组合索引**、**唯一索引**、**普通索引**。这些索引类型并不是按照同一维度进行区分的，按照索引数据完整度，可以分为聚簇索引和非聚簇索引，聚簇索引保存所有记录字段，非聚簇索引仅仅保存索引字段；按照索引字段数量，可以分为单列索引和组合索引；按照索引定义方式，可以分为普通索引和其他索引（包括唯一索引等）。

**聚簇索引和非聚簇索引**

InnoDB 存储引擎的表会存在主键（唯一非null），如果建表的时候没有指定主键，则会使用第一个非空的唯一索引作为聚簇索引，否则InnoDB会自动帮你创建一个不可见的、长度为6字节的row_id用来作为聚簇索引，聚簇索引保存了记录的所有字段，一张表只有一个聚簇索引。除了聚簇索引外的其他索引都可以称作非聚簇索引。

**主键索引和唯一索引**

InnoDB 存储引擎的表的主键构建的索引叫作主键索引，主键不允许为空且不能重复。唯一索引跟主键索引稍有不同，索引列的值同样必须唯一，但允许有空值。主键索引是一种特殊的唯一索引，不允许有空值。

**普通索引**

主键索引和唯一索引是 mysql 内部为约束字段构建的索引，除此以外用户自定义的索引就是普通索引。普通索引可以自由组合字段，允许在定义索引的列中插入重复值和空值

**单列索引和组合索引**

索引由一个字段组成就叫作单列索引，由多个字段组成就叫作组合索引。组合索引是实际开发中建的比较多的，也是优化的主要对象。

## 索引优化

### 建索引的原则

1. 为常作为查询条件的字段建立索引，走覆盖索引，避免回表
2. 对于修改比较多的表，尽量少建索引，因为修改的同时进行索引的维护，索引的维护其实就是对索引文件 B+ 树进行节点分裂合并
3. 选取区分度高的字段建索引

### 最左前缀匹配原则

最左前缀匹配原则针对的是组合索引，如以 User 表的 name 和 city 建组合索引（name,city），**最左前缀匹配原则指的是，如果查询的时候查询过滤条件精确匹配索引的左边连续一列或几列，则查询就会走这些索引列**：

```sql
select * from user where name=xx and city=xx ; // 可以命中索引, name 和 city 都走索引
select * from user where name=xx ; // 可以命中索引，name 走索引
select * from user where city=xx ; // 无法命中索引(这里其实不完全是无法命中索引，下面会说)    
```

最左前缀匹配的过程其实就是 B+ 树的查找过程，例如，一个组合索引（a,b）的存储结构大致如下图，B+ 树节点按照索引顺序依次排序构建，也就是说先按 a 排序，在 a 相同的情况下再按 b 排序。在 a 不相同的情况下，b 的大小没有关系，因此不能直接跳过 a 从索引去找 b，因为这样还是必须扫描整个 B+ 树，理解这一特点也就好理解索引的失效和生效情况了。

<img src="../image/image-20220505225332371.png" alt="image-20220505225332371" style="zoom:50%;" />



#### 索引失效的情况

```SQL
-- 前提条件假设 (user_id,age) 是组合索引
-- 1. where 过滤条件包含 or 时，可能会导致索引失效
-- 因此尽量避免使用or语句，可以根据情况使用 union all 或者 in 来代替
select * from user where user_id = 1 or age = 20;

-- 2. where 过滤条件使用了否定谓词查询，可能会导致索引失效，如 NOT、!=、<>、!<、!>、NOT IN、NOT LIKE 等
select * from user where user_id != 12;

-- 3. where 过滤条件使用 is null 或 is not null，可能会导致索引失效
select * from user where user_id is not null;

-- 4. where 过滤条件在索引列上使用函数或者计算，一定会导致索引失效
select * from user where user_id+1 = 2;

-- 5. where 过滤条件使用 like 模糊查询，可能导致索引失效
select * from user where user_id = 1 and age like '%0'; -- 这个会走 user_id 索引，但是不会走 age 索引
select * from user where user_id = 1 and age like '2%'; -- 这个会走 user_id 索引，也会走 age 索引 

-- 6. 组合索引中违背最左前缀匹配原则的查询，也就是说只要遇到第一个无法走索引的字段，后面的字段过滤都不走索引了
select * from user where user_id = 1 and age = 20; -- 走 user_id索引，走 age 索引
select * from user where user_id = 1 and age > 20; -- 走 user_id索引，但是不走 age 索引
select * from user where user_id > 1 and age = 20; -- 不走索引
```

#### 索引生效的情况

```sql
-- 除了上述索引失效的情况外，其他情况基本都可以走索引，这里几个特殊的也可以走索引的情况
-- 前提条件（a,b,c）组合索引
-- 1. 如果 where 使用索引的最左前缀定义为常量，则 order by 能使用索引
where a=const order by b,c
where a=const and b=const order by c
where a=const and b > const order by b,c

-- 2. 不能使用索引进行排 order by 排序的情况
order by a, b desc, c desc  -- 排序不一致
where d=const order by b,c   -- a丢失
where a=const order by c     -- b丢失
where a=const order by b,d   -- d不是索引的一部分
where a in(...) order by b,c -- a属于范围查询
```

需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 `city=xx and name＝xx`，那么高版本的**查询引擎会自动优化为匹配联合索引的顺序，这样其实也是能够命中索引的**。这里就涉及高版本 MySQL 的优化了，具体 SQL 还需借助 explain 进行分析，例如：

### 高版本 InnoDB 对查询的优化

考虑如下场景，有这样的一张表，建表语句如下：

```sql
CREATE TABLE test (
    id         INT NOT NULL,
    last_name  CHAR(30) NOT NULL,
    first_name CHAR(30) NOT NULL,
    PRIMARY KEY (id),
    INDEX name (last_name,first_name)
);
```

name 是一个包含了 last_name 和 first_name 列的组合索引。该索引可以用于 last_name 和 first_name 指定的一个范围的查询，也可以只用于只指定了 last_name  列的查询，因为这个列是索引的一个 **最左前缀**，因此索引 name 的几种生效情况如下：

```sql
-- name 索引生效
SELECT * FROM test WHERE last_name='Jones';
SELECT * FROM test WHERE last_name='Jones' AND first_name='John';
SELECT * FROM test WHERE last_name='Jones' AND (first_name='John' OR first_name='Jon');
SELECT * FROM test WHERE last_name='Jones' AND first_name >='M' AND first_name < 'N';

-- name 索引不生效
SELECT * FROM test WHERE first_name='John';
SELECT * FROM test WHERE last_name='Jones' OR first_name='John';
```

接着来看一下两个 explain 语句：

```sql
explain select * from test where last_name='Jones';
```

![image-20220506120927203](../image/image-20220506120927203.png)

```sql
explain select * from test where first_name='Cris';
```

![image-20220506121006606](../image/image-20220506121006606.png)

从结果可以看到，这两条 SQL 都会走 name 索引，不符合最左前缀原则吗？其实这里是 InnoDB 的进一步优化，上述的两条 explain 的执行结果中， type 是不一样的，一个是 ref ，一个是 index 。当查询的列是一个索引的最左前缀或者是一个普通索引（不是主键索引或唯一索引）会使用 ref，ref 只会读取匹配的行，因此走 ref 通常返回的结果集会比较小；index 是扫描索引树，如果查询的索引是覆盖索引，并且满足要从该表中查询的数据需求时，则仅扫描索引树。在这种情况下，Extra 列为 Using index。**索引扫描会比 ALL 快，因为索引树通常小于整个表**。

## explain 查询计划

exlain 是 SQL 分析调优的一个重要工具，如下图，可以分析一条 SQL 的执行计划，获取走了哪些索引，每一步返回多少数据等信息。

![image-20220505212045650](../image/image-20220505212045650.png)

explain 结果的相关字段说明：

| 字段          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| id            | 数字越大越先执行，数字一样大，就从上往下依次执行             |
| select_type   | SIMPLE：简单SELECT；PRIMARY：最外层SELECT；还有其他          |
| table         | 从哪张表查，不一定是实际存在的表名，可以是子查询的结果：derivedN，N是id，代表id为N的子查询的结果集 |
| partitions    | 非分区表该字段为空                                           |
| type          | 重要字段，查询的类型。<br />**ref**：若联接只用到索引的最左前缀或索引不是主键或唯一索引<br />**index**: 索引全表扫描，把索引从头到尾扫一遍。包含两种情况：一种是查询使用了覆盖索引，那么只需扫描索引就可以获得数据，这个效率要比全表扫描要快，因为索引通常比数据表小，而且还能避免二次查询。在 extra 中显示Using index，反之，如果在索引的基础上进行全表扫描，没有 Using index 提示<br />**eq_ref**：在当前表中只能找到一行，当主键或唯一非 NULL 索引的所有字段都被用作 join 条件时会使用此类型，比较高效<br />其他类型，用的时候再查 |
| possible_keys | 查询可能使用到的索引都会在这里列出来，SQL 中可以指定走哪个索引，如：<br />SELECT round FROM arena_match_index **use index (dg)** WHERE `day` = '2022-05-05' AND `group` = 18 AND `begintime` < '2022-05-05 12:00:00' order by begintime LIMIT 1; |
| key           | 查询真正使用到的索引                                         |
| key_len       | 查询用到的索引长度                                           |
| ref           | 如果是使用的常数等值查询，这里会显示const<br />如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段<br />如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func |
| rows          | 重要的字段，这是mysql估算的需要扫描的行数（不是精确值），这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好 |
| filtered      | 表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数。这个字段不重要 |
| Extra         | 重要字段，提供额外信息，常见的有：<br />**distinct**：表示在 select 部分使用了 distinc 关键字<br />**Using filesort**：表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果，一般有 Using filesort 都建议优化去掉, 因为这样的查询 CPU 资源消耗大<br />**Using index**：表示覆盖索引扫描, 在索引树中就可查找所需数据, 不用扫描表数据文件, 说明性能不错<br />**Using temporary**：表示查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化 |