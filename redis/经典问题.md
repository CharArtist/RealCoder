# 经典问题

## 潜在性能瓶颈

Redis单线程处理 IO 请求，潜在的性能瓶颈主要包括2个方面：

1. 任意一个请求在 server 中一旦发生耗时，都会影响整个 server 的性能 也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。

耗时的操作包括：

- **操作bigkey**：写入一个 bigkey 在分配内存时需要消耗更多的时间，同样，删除 bigkey 释放内存同样会产生耗时
- **使用复杂度过高的命令**：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，一次查询全量数据
- **大量key集中过期**：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长
- **淘汰策略**：溜达策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长
- **AOF刷盘开启always机制**：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能
- **主从全量同步生成RDB**：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久

解决办法：

- 需要业务人员去规避
- Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响

2. 并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。

解决办法：

- Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能
- 当然，只针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的

## 缓存雪崩



## 缓存穿透

缓存和数据库都没有的数据，请求都打到数据库，如果被恶意用户利用，疯狂请求不存在的数据，就会导致数据库压力过大，甚至垮掉。

## 缓存击穿

缓存击穿是指数据库有数据，但是缓存中没有，一般是缓存突然失效了，这时候如果有大量用户请求该数据，缓存没有则会去数据库请求，会引发数据库压力增大，可能会瞬间打垮。

针对这类问题，一般有以下做法：

1. 如果是热点数据，那么可以考虑设置永远不过期。
2. 如果数据一定会过期，设置一个互斥的锁或者并发访问限制，只让一个或者一部分请求去数据库拉取数据，取完数据，不管如何都需要释放锁，异常的时候也需要释放锁，不然其他线程会一直拿不到锁

## 如何保证数据库和 Redis 缓存的数据一致



## 如何避免同时大范围key过期