# 经典问题

## 潜在性能瓶颈

Redis单线程处理 IO 请求，潜在的性能瓶颈主要包括2个方面：

1. 任意一个请求在 server 中一旦发生耗时，都会影响整个 server 的性能 也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。

耗时的操作包括：

- **操作bigkey**：写入一个 bigkey 在分配内存时需要消耗更多的时间，同样，删除 bigkey 释放内存同样会产生耗时
- **使用复杂度过高的命令**：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，一次查询全量数据
- **大量key集中过期**：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长
- **淘汰策略**：溜达策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长
- **AOF刷盘开启always机制**：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能
- **主从全量同步生成RDB**：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久

解决办法：

- 需要业务人员去规避
- Redis在4.0推出了lazy-free机制，把bigkey释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响

2. 并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO，只能单线程依次读取客户端的数据，无法利用到CPU多核。

解决办法：

- Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能
- 当然，只针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的

## 缓存雪崩



## 缓存穿透

